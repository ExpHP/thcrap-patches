#!/usr/bin/env python3

__doc__ = """
Helper library for "binhack scripts", which are automatible ways of making binhacks.
"""

import collections
import keystone
import random
import re

class LocatableSymbolResolver:
    """
    An ``OPT_SYM_RESOLVER`` for keystone designed to help identify the byte offset into the
    assembled output where a symbol appears (possibly relative to the instruction pointer).

    Basically, it can be used to generate a number of single-use symbols that should each
    appear *at most once* in the input assembly. Then, it locates these symbols by assembling
    an asm string multiple times while changing the symbol addresses.
    """
    def __init__(self):
        self._random_prefix = f'{random.randrange(2**64):016x}'
        self._next_suffix = 0
        self._values = {}

    def gen_symbol(self, init_value=0x12345678):
        """ Generate a new single-use symbol. """
        symbol = f'_{self._random_prefix}_{len(self._values)}'
        self._values[symbol] = init_value
        return symbol

    def symbols(self):
        """ Get all symbols generated by this object. """
        return [f'_{self._random_prefix}_{i}' for i in range(self._next_suffix)]

    def toggle_bits(self, symbol):
        self._values[symbol] = 0xffffffff - self._values[symbol]

    def assemble_and_locate_symbols(self, keystone, asm):
        """
        Assemble a string using the given ``keystone``, and also identify the byte offset of each symbol.
        Returns ``(bytes, {symbol: (start, stop)})``.  ``(start, stop)`` are semi-inclusive ranges.
        Symbols not present in the asm string will not be in the returned dict.

        The assembly and initial value of each symbol must be such that flipping the bits of each symbol
        modifies exactly four (4) contiguous bytes of the output. In the output bytes, the value of these
        four bytes will be arbitrary.

        Note: This has the side-effect of setting ``keystone.sym_resolver``.
        """
        keystone.sym_resolver = self
        original_output = keystone.asm(asm)[0]
        if original_output is None:
            raise RuntimeError(f"keystone 'successfully' returned None.  Typically this happens if you write 'dword' instead of 'dword ptr'.")

        locations = {}
        for symbol in self._values:
            self.toggle_bits(symbol)
            flipped_output = keystone.asm(asm)[0]
            loc = self.__locate_flipped_dword(flipped_output, original_output)
            if loc is not None:
                locations[symbol] = loc
            self.toggle_bits(symbol)

        return (original_output, locations)

    @staticmethod
    def __locate_flipped_dword(a, b):
        if len(a) != len(b):
            raise RuntimeError('output assembly length changed!')
        if a == b:
            return None  # symbol not used

        for start in range(len(a)):
            if a[start] != b[start]:
                break

        for stop in range(start + 1, len(a)):
            if a[stop] == b[stop]:
                break
        else: stop = len(a)

        if a[stop:] != b[stop:]:
            raise RuntimeError(f'more than one slice of bytes changed! (symbol may have been reused?)')

        return (start, stop)

    def __call__(self, symbol, output_ptr):
        symbol = symbol.decode('ascii')
        if symbol in self._values:
            output_ptr[0] = self._values[symbol]
            return True
        else:
            return False

class Codecaves:
    def __init__(self, auto_prefix=''):
        self.auto_prefix = auto_prefix
        self.resolver = LocatableSymbolResolver()
        self.replacements = {}

    def get_auto_name(self, name):
        return self.auto_prefix + name

    def rel_auto(self, name):
        """ Generate a single-use symbol that will be replaced with ``[codecave:...]``
        (thcrap relative ref syntax) in the final output, adding the ``auto_prefix``. """
        return self._gen_codecave_ref(self.get_auto_name(name), kind='rel')
    def abs_auto(self, name):
        """ Generate a single-use symbol that will be replaced with ``<codecave:...>``
        (thcrap absolute ref syntax) in the final output, adding the ``auto_prefix``. """
        return self._gen_codecave_ref(self.get_auto_name(name), kind='abs')
    def rel_global(self, name):
        """ Generate a single-use symbol that will be replaced with ``[codecave:...]``
        (thcrap relative ref syntax) in the final output, WITHOUT adding the ``auto_prefix``. """
        return self._gen_codecave_ref(self.get_auto_name(name), kind='rel')
    def abs_global(self, name):
        """ Generate a single-use symbol that will be replaced with ``<codecave:...>``
        (thcrap absolute ref syntax) in the final output, WITHOUT adding the ``auto_prefix``. """
        return self._gen_codecave_ref(self.get_auto_name(name), kind='abs')
    def jmp(self, addr):
        return f'''
            call next
        next:
            mov dword ptr [esp], {addr:#x}
            ret
        '''

    def _gen_codecave_ref(self, name, kind):
        symbol = self.resolver.gen_symbol()
        if kind == 'abs':
            self.replacements[symbol] = f'<codecave:{name}>'
        elif kind == 'rel':
            self.replacements[symbol] = f'[codecave:{name}]'
        else:
            raise ValueError(f'bad kind: {repr(kind)}')

        return symbol

    @staticmethod
    def _check_for_footguns(asm):
        pass

    def _asm_to_thcrap_hex(self, asm):
        _check_asm_for_footguns(asm)
        ks = keystone.Ks(keystone.KS_ARCH_X86, keystone.KS_MODE_32)
        bits, locations = self.resolver.assemble_and_locate_symbols(ks, asm)

        prev_stop = 0
        hex_parts = []
        # iterate locations in reverse
        sorted_locations = sorted(locations.items(), key=lambda tup: tup[1][0])
        for symbol, (start, stop) in reversed(sorted_locations):
            replacement = self.replacements[symbol]
            if stop - start != 4:
                raise RuntimeError(f'symbol {symbol} ({replacement}) occupies bytes {start}:{stop} which is not a dword!')

            # add untouched hex chars
            hex_parts.append(bytes_to_hex(bits[prev_stop:start]))
            # add thcrap [] or <> ref
            hex_parts.append(replacement)
            prev_stop = stop
        # untouched hex chars after the final reference
        hex_parts.append(bytes_to_hex(bits[prev_stop:]))
        return ''.join(hex_parts)

def bytes_to_hex(bits):
    """ Convert bytes to a hex string. """
    return ''.join(f'{x:02x}' for x in bits)

# Keystone fails in an unusual way ("successfully" returning None) without the ptr keyword.
# (Ironically, checking github, I've only found an issue reporting the OPPOSITE effect, where
#   it returns None if you DO include 'ptr'!)
SIZE_WITHOUT_PTR_REGEX = re.compile(r'\b(byte|(|d|q|xmm|ymm|zmm)word) +(?!ptr)', re.IGNORECASE)
# Keystone has 0-prefix octal.  Ugh.
OCTAL_REGEX = re.compile(r'\b0[0-9]+')
# Issue: https://github.com/keystone-engine/keystone/issues/481
# Basically, decimal numbers are dangerous due to a bug in keystone that arbitrarily
# changes the default radix to 16.  Always format numbers using '{:#x}'.
POSSIBLY_IMPLICIT_HEX_REGEX = re.compile(r'\b[1-9][0-9]+')
def _check_asm_for_footguns(asm):
    for line in asm.splitlines():
        if '#' in line:
            line = line[:line.index('#')]
        if SIZE_WITHOUT_PTR_REGEX.search(line):
            raise ValueError("detected size operand without 'ptr' keyword!")
        m = OCTAL_REGEX.search(line)
        if m:
            raise ValueError(f"detected integer with leading zero: {m.group(0)}")
        m = POSSIBLY_IMPLICIT_HEX_REGEX.search(line)
        if m:
            raise ValueError(f"detected decimal integer: {m.group(0)}  (see keystone issue #481)")

class BinhackCollection:
    def __init__(self, name, callback):
        self.callback = callback
        self.name = name
        self.binhacks = {}

    def _format_name(self, args):
        argstr = ', '.join(map(str, args))
        return f'{self.name}({argstr})'

    def __call__(self, *args):
        name_with_args = self._format_name(args)
        if name_with_args not in self.binhacks:
            self.binhacks[name_with_args] = Binhack(self.callback(*args))
        return self.binhacks[name_with_args]

class ThcrapGen:
    def __init__(self, auto_prefix=None):
        self.auto_prefix = auto_prefix
        self.binhack_collections = {}
        self.single_binhacks = {}

    def binhack_collection(self, name, callback):
        """
        Define a new parameterized collection of binhacks.
        """
        name = (self.auto_prefix or '') + name
        if name in self.binhack_collections:
            raise KeyError(f'binhack collection {repr(name)} already exists')
        self.binhack_collections[name] = BinhackCollection(name=name, callback=callback)
        return self.binhack_collections[name]

    def binhack(self, name, binhack):
        if name in self.single_binhacks:
            raise KeyError(f'binhack {repr(name)} already exists')
        self.single_binhacks[name] = Binhack(binhack)
        return self.single_binhacks[name]

    def asm(self, asm):
        caves = Codecaves(auto_prefix=self.auto_prefix)
        if callable(asm):
            asm = asm(caves)
        return caves._asm_to_thcrap_hex(asm)

    def cereal(self):
        cereal = {'binhacks': {}}
        for key, binhack in self.single_binhacks.items():
            cereal['binhacks'][key] = dict(binhack)
        for collection in self.binhack_collections.values():
            # note: the dict(v) is to strip the Binhack subclass for ruamel.yaml
            cereal['binhacks'].update([(k, dict(v)) for (k, v) in collection.binhacks.items()])
        
        # Make sure all addresses are hexadecimal strings
        def hexify_if_int(x):
            if isinstance(x, int): return f'{x:#x}'
            else: return x

        for binhack in cereal['binhacks'].values():
            if 'addr' not in binhack: continue
            binhack['addr'] = hexify_if_int(binhack['addr'])
            if isinstance(binhack['addr'], list):
                binhack['addr'] = [hexify_if_int(x) for x in binhack['addr']]
        return cereal

class Binhack(dict):
    """ dict for the yaml of a single binhack, with convenience methods. """
    def at(self, addr):
        """ Adds an address (or iterable of addresses) to 'addr'. """
        if isinstance(addr, collections.Iterable):
            for x in addr: self.at(x)
            return

        if 'addr' not in self:
            self['addr'] = []
        if isinstance(self['addr'], (str, int)):
            self['addr'] = [self['addr']]

        self['addr'].append(addr)

def default_arg_parser(require_game=False):
    import argparse
    p = argparse.ArgumentParser(
        description='A binhack generating script.'
    )
    p.add_argument(
        '--game', required=require_game, type=Game,
        help='Game string.  Valid examples: th08, th08.v1.00d.  Invalid examples: 08, th8, TH08',
    )
    return p

GAME_BASE_RE = re.compile(r'th[012][0-9]{1,2}')
class Game:
    """
    Represents a Touhou game number, e.g. 'th08' or 'th08.v1.00d'.  Can be compared to plain
    python strings using equality and comparison operators.

    NOTE: Currently the version part is ignored.  alcostg is also not supported.
    """
    def __init__(self, game):
        if isinstance(game, Game):
            self.ordered_string = game.ordered_string
        else:
            base = game.split('.')[0]  # strip version part
            if not GAME_BASE_RE.match(base):
                raise ValueError(f'invalid game: {repr(base)}')
            # the pattern satisfied by base forms a lexical order
            self.ordered_string = base

    def __hash__(self): return self.ordered_string.__hash__()
    def __str__(self): return self.ordered_string
    def __repr__(self): return f'Game({repr(self.ordered_string)})'
    def __eq__(self, other): return self.ordered_string.__eq__(Game(other).ordered_string)
    def __ne__(self, other): return self.ordered_string.__ne__(Game(other).ordered_string)
    def __lt__(self, other): return self.ordered_string.__lt__(Game(other).ordered_string)
    def __le__(self, other): return self.ordered_string.__le__(Game(other).ordered_string)
    def __gt__(self, other): return self.ordered_string.__gt__(Game(other).ordered_string)
    def __ge__(self, other): return self.ordered_string.__ge__(Game(other).ordered_string)
