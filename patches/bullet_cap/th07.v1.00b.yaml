# this yaml file is auto-generated
codecaves:
    # AUTO_PREFIX: ExpHP.bullet-cap.

    # %include "util.asm"
    # Push several things.
    # %macro multipush  0-*.nolist
    # %rep  %0
    # push    %1
    # %rotate 1
    # %endrep
    # %endmacro

    # Pop several things, in reverse order.
    # %macro multipop  0-*.nolist
    # %rep %0 
    # %rotate -1
    # pop     %1
    # %endrep 
    # %endmacro

    # side-effect-free absolute jump
    # %macro abs_jmp_hack  1.nolist
    # call %%next
    # %%next:
    # mov dword [esp], %1
    # ret
    # %endmacro

    # Absolute call, clobbering eax.
    #
    # eax is almost universally a good choice since it's used for return values,
    # but some functions from the ugly ABI era pass an argument in eax.
    #
    # (if this were x86-64, we could use the red zone, but it doesn't exist in x86)
    # %macro call_eax  1.nolist
    # mov eax, %1
    # call eax
    # %endmacro

    # %macro die  0.nolist
    # push __LINE__
    # int 3
    # %endmacro

    # %define SIGN_MASK 0x80000000

    #================================================================
    # Simple stack frame automation that just saves esi/edi.
    #
    # NOTE: These have been superceded by the func_* macros but are still used in older code.

    # Create a stack frame and push esi and edi.  Clean up with epilogue_sd.
    # %macro prologue_sd  0.nolist
    # push ebp
    # mov  ebp, esp
    # push esi
    # push edi
    # %endmacro

    # Create a stack frame, decrease the stack pointer by a specified number of bytes to create locals,
    # and push esi and edi.  Clean up with epilogue_sd.
    # %macro prologue_sd  1.nolist
    # push ebp
    # mov  ebp, esp
    # sub  esp, %1
    # push esi
    # push edi
    # %endmacro

    # Clean up for prologue_sd.
    # %macro epilogue_sd  0.nolist
    # pop  edi
    # pop  esi
    # mov  esp, ebp
    # pop  ebp
    # %endmacro

    #================================================================
    # Automation of stack locals and stdcall returns.
    #
    # Yes, nasm has %arg and %local but:
    #
    # - They are only capable of creating globally scoped variables, leading to some of
    #   the nastiest bugs to pin down (accidental reuse of an old variable when there is
    #   a typo or omission in your arg list).  These support '%$name'.
    # - %arg can't automate the stdcall 'ret N'.
    #
    # Usage:
    #
    #    func_begin          ; enables the use of the other macros
    #    func_arg    %$x, %$y, %$z   ; these will be set to 'ebp+0x08', 'ebp+0x0c', 'ebp+0x10'
    #    func_local  %$a, %$b, %$c   ; these will be set to 'ebp-0x04', 'ebp-0x08', 'ebp-0x0c'
    #    func_prologue esi, edi  ; creates stack frame, creates space for func_locals, saves esi/edi
    #    .....code.....
    #    func_epilogue       ; restores esi/edi, cleans stack frame
    #    func_ret            ; will do 'ret 0xc' (computing correct size from func_args)
    #    func_end            ; cleans up preprocessor state
    #
    # These macros use named contexts (__func__meta and __func__body) only to help catch mistakes
    # in their usage.

    # Use once at the beginning of a function to enables the use of func_arg and func_local.
    # It merely creates a context for '%$name' variables, and does not generate any instructions.
    # %macro func_begin  0.nolist
    # %ifctx __func__meta
    # %error "func_end was not called"
    # %elifctx __func__body
    # %error "func_end was not called"
    # %endif
    # %push __func__meta
    # %assign %$__argsize 0
    # %assign %$__localsize 0
    # %endmacro

    # Define names for dword-sized stack arguments.  The first name will be set to 'ebp+0x08'
    # (anticipating the creation of a stack frame), the second will be set to 'ebp+0x0c', etc.
    #
    # You can split the args up over multiple invocations of this macro (e.g. to add comments).
    #
    # The total number of args will determine the argument to 'ret' later.
    # %macro func_arg  0-*.nolist
    # %ifctx __func__body
    # %error "func_arg after prologue"
    # %elifnctx __func__meta
    # %error "func_arg without func_begin"
    # %endif

    # %define __things_to_pop %{-1:1}
    # %rep %0
    # %xdefine %1 ebp+0x08+%$__argsize
    # %assign %$__argsize %$__argsize+4
    # %rotate 1
    # %endrep
    # %endmacro

    # Define names for dword-sized stack locals.  The first name will be set to 'ebp-0x04'
    # (anticipating the creation of a stack frame), the second will be set to 'ebp-0x08', etc.
    #
    # You can split the vars up over multiple invocations of this macro (e.g. to add comments).
    #
    # The total size of the vars will be subtracted from 'esp' at the appropriate point during
    # stack frame creation in 'func_prologue'.
    # %macro func_local  0-*.nolist
    # %ifctx __func__body
    # %error "func_local after prologue"
    # %elifnctx __func__meta
    # %error "func_local without func_begin"
    # %endif

    # %rep %0
    # %xdefine %1 ebp-0x04-%$__localsize
    # %assign %$__localsize %$__localsize+4
    # %rotate 1
    # %endrep
    # %endmacro

    # Generates a function prologue that creates a stack frame (with space for the locals
    # declared in func_local) and saves the listed registers.  This must be called even
    # if no locals are created, because func_arg still assumes that a stack frame is created.
    #
    # For best practices, it is recommended to save esi and edi even if they are not used,
    # so that uses of them can be comfortably added to any function. (i.e. if a function does
    # not save edi/esi, it should stick out like a sore thumb, and be done with purpose)
    #
    # A function must have exactly one call to this macro.
    # %macro func_prologue  0-1+.nolist
    # %ifctx __func__meta
    # %repl __func__body
    # %else
    # %error "func_prologue without func_begin"
    # %endif

    # push ebp
    # mov  ebp, esp
    # sub  esp, %$__localsize
    # multipush %1
    # %define  %$__things_to_pop  %1
    # %endmacro

    # Cleanup for func_prologue.
    #
    # You can use this multiple times if you have multiple exit points.
    # %macro func_epilogue  0.nolist
    # %ifnctx __func__body
    # %error "func_epilogue without func_prologue"
    # %endif

    # multipop  %$__things_to_pop
    # mov  esp, ebp
    # pop  ebp
    # %endmacro

    # A stdcall-style 'ret num_bytes' that automatically computes the number of bytes from
    # the calls to the func_arg macro.
    #
    # You can use this multiple times if you have multiple exit points.
    # %macro func_ret  0.nolist
    # ret %$__argsize
    # %endmacro

    # This must be called once at the very end of a function definition.
    # It does not generate any code.
    # %macro func_end  0.nolist
    # %ifctx __func__meta
    # %error "function had no prologue!"
    # %else
    # this is inside an %else because otherwise the automatic error message from a
    # mismatched %pop would prevent all of our nicer error messages from being shown
    # %pop __func__body
    # %endif
    # %endmacro
    # %include "common.asm"
    # IDs for global structs that can be affected by this mod.
    # %define STRUCT_BULLET_MGR  1
    # %define STRUCT_ITEM_MGR    2
    # %define __STRUCT_TEST  0x20

    # IDs for the modifiable caps.
    # %define CAPID_BULLET 0x40
    # %define CAPID_LASER  0x41
    # %define CAPID_CANCEL 0x42
    # %define __CAPID_TEST_1 0x80
    # %define __CAPID_TEST_2 0x81

    # =============================
    #        CAP CHANGES
    # =============================
    # Each cap changed by the patch includes a list of values to change.


    # Each entry in the list of replacements contains:
    # - A value to change.
    # - A scale constant (documented below) describing how the value should change in relation to the cap.
    # - A whitelist or blacklist.

    # ================================
    #        STRUCT LAYOUT
    # ================================
    # Each struct modified by the patch has a layout described how the patch modifies it.
    # This layout uses the following types:


    # Used if struct is located behind a pointer in static memory.
    # %define LOCATION_PTR(addr)             addr, 1
    # Used if struct is directly embedded in static memory.
    # %define LOCATION_STATIC(addr)          addr, 0


    # RegionEntry is constructed by one of the following macros:
    #
    # Indicates a range of fields we don't modify starting at a given offset.
    # %define REGION_NORMAL(start)                            start, 0, 0, 0, 0
    # Indicates an array that we resize starting at a given offset.
    # %define REGION_ARRAY(start, capid, scale)               start, capid, 0, scale, scale
    # Indicates an array that we move behind a pointer and resize, starting at a given offset.
    # %define REGION_ARRAY_POINTERIZED(start, capid, scale)  start, capid, _REGION_FLAG_POINTERIZED, scale, 0
    # Marks the struct size as the final offset.
    # %define REGION_END(end)                                 REGION_NORMAL(end), _REGION_TOKEN_END

    # Sentinel used after final offset.
    # %define _REGION_TOKEN_END   0xabcdefed
    # Indicates that a region of the struct has been pointerized
    # %define _REGION_FLAG_POINTERIZED  0x1

    # After that is a list of offsets to change.  Each entry consists of:
    #
    # - An offset to change, or the DWORD_RANGE() macro.
    # - A blacklist or whitelist.
    #
    # One might wonder, why have lists under structs in addition to lists for each cap?
    # The reason is because struct offsets could be affected by more than one array.
    # (e.g. if we had a normal item cap and cancel item cap).
    #
    # In contrast to the lists associated with caps, these lists defer to the struct's
    # layout when replacing values, rather than using scale constants.

    # Replaces values in the half-open range from start to end, instead of a single value.
    # %define DWORD_RANGE(start, end)  DWORD_RANGE_TOKEN, start, end
    # Useful if the range ends in an array and you want to remap that too I guess.
    # %define DWORD_RANGE_INCLUSIVE(start, end)  DWORD_RANGE(start, end+1)
    # %define DWORD_RANGE_TOKEN -47

    # ================================
    #        SCALE CONSTANTS
    # ================================
    #
    # Scale constants are used to represent how much a value should change in response to
    # a cap being changed.  For instance, the length of an array of bullets would change by
    # the bullet size for each difference of 1 in the cap (SCALE_SIZE), whereas a value like
    # "the cap plus 1" would only change by 1 for each such difference (SCALE_1).
    #
    # There are some trickier examples to deal with stuff like 'rep stosd' and unrolled loops.

    # The value to be replaced is followed by a "scale_constant", which is one of the following:
    #
    #              SCALE_1 :  Maps value as `value -> value + (new_cap - old_cap)`.
    #                         Used on array sizes and iteration counts.
    #
    #           SCALE_SIZE :  Maps value as `value -> value + (new_cap - old_cap) * elem_size`.
    #                         Typically used for byte offsets of things after the array.
    #
    #    SCALE_SIZE_DIV(n) :  Maps value as `value -> value + (new_cap - old_cap) * elem_size / n`.
    #                         Needed to handle things like `rep stosd`.
    #
    #       SCALE_1_DIV(n) :  Maps value as  `value -> value + (new_cap - old_cap) / n`.
    #                         Both `old_cap` and `new_cap` must be divisible by `n`. If `new_cap` isn't, a user-facing error is displayed.
    #                         This is used to deal with some stupidly-unrolled loops in some games until I have
    #                         the time and energy to write more binhacks to un-unroll them.
    #
    #       SCALE_FIXED(b) :  Maps value as `value -> value + (new_cap - old_cap) * b`.
    #                         e.g. LoLK has an array of dwords the same length as the bullet array,
    #                         so one would use `SCALE_FIXED(4)` to handle this array.
    #
    #
    # IMPORTANT:  The mappings shown above are for positive original values.  Negative original values are mapped in such a way
    #             that smaller caps produce final values closer to zero, so you should still write positive scales.

    # Stored as 3 bytes of a dword.
    # %define SCALE_GENERAL(size_mult, one_mult, divisor)  size_mult + one_mult * 0x100 + divisor * 0x10000
    # %define SCALE_1               SCALE_GENERAL(0, 1, 1)
    # %define SCALE_SIZE            SCALE_GENERAL(1, 0, 1)
    # %define SCALE_SIZE_DIV(n)     SCALE_GENERAL(1, 0, n)
    # %define SCALE_1_DIV(n)        SCALE_GENERAL(0, 1, n)
    # %define SCALE_FIXED(b)        SCALE_GENERAL(0, b, 1)

    # -----------------------

    # After the scale expression is either a whitelist of addresses to replace, or a blacklist of addresses to NOT replace.

    # %define WHITELIST_BEGIN 1
    # %define WHITELIST_END   0
    # %define BLACKLIST_BEGIN -1
    # %define BLACKLIST_END   0
    # Synonym for an empty blacklist, since BLACKLIST_BEGIN BLACKLIST_END feels noisy and
    # makes it harder to notice the size constant.
    # %define REPLACE_ALL -1, 0

    # After the last entry is LIST_END.

    # %define LIST_END 0

    # ================================
    # SPECIALIZED STUFF FOR SOME GAMES
    # ================================




    # ===============================

    # Override functions from base_exphp.
    # REMINDER: These functions must additionally preserve ecx and edx.

  base-exphp.adjust-bullet-array:
    - "8B442404          " # mov  eax, [esp+0x4]
    - "8B00              " # mov  eax, [eax]  ; deref pointer
    - "C3                " # ret
  base-exphp.adjust-laser-array:
    - "8B442404          " # mov  eax, [esp+0x4]
    - "8B00              " # mov  eax, [eax]  ; deref pointer
    - "C3                " # ret
  base-exphp.adjust-cancel-array:
    - "8B442404          " # mov  eax, [esp+0x4]
    - "8B00              " # mov  eax, [eax]  ; deref pointer
    - "C3                " # ret

    # ===============================

    # Address range spanned by .text
  ExpHP.bullet-cap.address-range:
    - "00104000          " # dd 0x401000
    - "38CD4800          " # dd 0x48cd38

  ExpHP.bullet-cap.bullet-replacements:
    # istruc ListHeader
    - "00040000          " # at ListHeader.old_cap, dd 0x400
    - "680D0000          " # at ListHeader.elem_size, dd 0xd68
    # iend
    - "00040000          " # dd 0x400
    - "00010100          " # dd SCALE_1
    - "01000000          " # dd WHITELIST_BEGIN

    - "927C4100          " # dd 0x417c92  ; Enemy::hardcoded_func_01_s2_call
    - "457F4100          " # dd 0x417f45  ; Enemy::hardcoded_func_02_s2_call
    - "A8814100          " # dd 0x4181a8  ; Enemy::hardcoded_func_04_s378_set
    - "39834100          " # dd 0x418339  ; Enemy::hardcoded_func_06_s3_call
    - "92894100          " # dd 0x418992  ; Enemy::hardcoded_func_07_s4_set
    - "6C8C4100          " # dd 0x418c6c  ; Enemy::hardcoded_func_08_s4_set
    - "088F4100          " # dd 0x418f08  ; Enemy::hardcoded_func_10_s5678_call
    - "03904100          " # dd 0x419003  ; Enemy::hardcoded_func_11_s5678_call
    - "CC914100          " # dd 0x4191cc  ; Enemy::hardcoded_func_12_s5_call
    - "14954100          " # dd 0x419514  ; Enemy::hardcoded_func_13_s5_set
    - "5C964100          " # dd 0x41965c  ; Enemy::hardcoded_func_14_s5_call
    - "6D974100          " # dd 0x41976d  ; Enemy::hardcoded_func_16_s6_call
    - "F4984100          " # dd 0x4198f4  ; Enemy::hardcoded_func_17_s6_call
    - "019A4100          " # dd 0x419a01  ; Enemy::hardcoded_func_18_s6_call
    - "F99A4100          " # dd 0x419af9  ; Enemy::hardcoded_func_21_s5_call_hl
    - "589E4100          " # dd 0x419e58  ; Enemy::hardcoded_func_22_s7_set
    - "84A04100          " # dd 0x41a084  ; Enemy::hardcoded_func_23_s8_set

    - "6C374200          " # dd 0x42376c  ; BulletManager::shoot_one
    - "B1374200          " # dd 0x4237b1  ; BulletManager::shoot_one
    - "72474200          " # dd 0x424772  ; BulletManager::sub_424740_cancels_bullets
    - "E6494200          " # dd 0x4249e6  ; BulletManager::sub_4249a0_cancels_bullets
    - "3B4C4200          " # dd 0x424c3b  ; BulletManager::sub_424c00_cancels_bullets
    - "2F4D4200          " # dd 0x424d2f  ; BulletManager::shoot_bullets

    - "185B4200          " # dd 0x425b18  ; BulletManager::on_tick_0c
    - "D1774200          " # dd 0x4277d1  ; BulletManager::sub_4277a0
    - "00000000          " # dd WHITELIST_END

    - "01040000          " # dd 0x401
    - "00010100          " # dd SCALE_1
    - "01000000          " # dd WHITELIST_BEGIN
    - "72334200          " # dd 0x423372  ; BulletManager::constructor
    - "00000000          " # dd WHITELIST_END

    # something wierd in BulletManager::on_tick where it needs to wrap, idfk why
    - "00A03500          " # dd 0x35a000  ; offset of dummy bullet from beginning of bullet array
    - "01000100          " # dd SCALE_SIZE
    - "01000000          " # dd WHITELIST_BEGIN
    - "A9634200          " # dd 0x4263a9  ; BulletManager::on_tick
    - "00000000          " # dd WHITELIST_END

    - "FF030000          " # dd 0x3ff  ; index of last bullet in bullet array
    - "00010100          " # dd SCALE_1
    - "01000000          " # dd WHITELIST_BEGIN
    - "A0634200          " # dd 0x4263a0  ; BulletManager::on_tick
    - "00000000          " # dd WHITELIST_END

    # No need to adjust field offsets because we use binhacks to replace the
    # embedded array with a pointer.

    - "00000000          " # dd LIST_END

  ExpHP.bullet-cap.laser-replacements:
    # istruc ListHeader
    - "40000000          " # at ListHeader.old_cap, dd 0x40
    - "EC040000          " # at ListHeader.elem_size, dd 0x4ec
    # iend
    - "40000000          " # dd 0x40
    - "00010100          " # dd SCALE_1
    - "01000000          " # dd WHITELIST_BEGIN
    # This is the only place where the cap appears as a dword sized value.
    # Everywhere else, it appears byte-sized and requires binhacks.
    - "AD334200          " # dd 0x4233b1 - 4  ; BulletManager::constructor
    - "00000000          " # dd WHITELIST_END
    - "00000000          " # dd LIST_END

  ExpHP.bullet-cap.cancel-replacements:
    # istruc ListHeader
    - "4C040000          " # at ListHeader.old_cap, dd 0x44c
    - "88020000          " # at ListHeader.elem_size, dd 0x288
    # iend
    - "4C040000          " # dd 0x44c
    - "00010100          " # dd SCALE_1
    - "01000000          " # dd WHITELIST_BEGIN
    - "4C274300          " # dd 0x43274c  ; ItemManager::spawn_item
    - "82274300          " # dd 0x432782  ; ItemManager::spawn_item
    - "B4274300          " # dd 0x4327b4  ; ItemManager::spawn_item
    - "61294300          " # dd 0x432961  ; ItemManager::spawn_item
    - "322A4300          " # dd 0x432a32  ; ItemManager::on_tick
    - "C03A4300          " # dd 0x433ac0  ; ItemManager::sub_433a90 (autocollect related?)
    - "503B4300          " # dd 0x433b50  ; ItemManager::sub_433b20 (autocollect related?)
    - "703C4300          " # dd 0x433c70  ; ItemManager::sub_433c40 (autocollect related?)
    - "00000000          " # dd WHITELIST_END

    - "4D040000          " # dd 0x44d
    - "00010100          " # dd SCALE_1
    - "01000000          " # dd WHITELIST_BEGIN
    - "3C264300          " # dd 0x43263c  ; ItemManager::constructor
    - "00000000          " # dd WHITELIST_END

    - "00000000          " # dd LIST_END

  ExpHP.bullet-cap.bullet-mgr-layout:
    # istruc LayoutHeader
    - "58F9620000000000  " # at LayoutHeader.location, dd LOCATION_STATIC(0x62f958)
    - "74000000          " # at LayoutHeader.offset_to_replacements, dd bullet_mgr_layout.replacements - bullet_mgr_layout
    # iend
    - "0000000000000000000000000000000000000000" # dd REGION_NORMAL(0)
    - "C0B8000040000000010000000100010000000000" # dd REGION_ARRAY_POINTERIZED(0xb8c0, CAPID_BULLET, SCALE_SIZE)
    - "2866360041000000010000000100010000000000" # dd REGION_ARRAY_POINTERIZED(0x366628, CAPID_LASER, SCALE_SIZE)
    - "28A1370000000000000000000000000000000000" # dd REGION_NORMAL(0x37a128)
    - "64A1370000000000000000000000000000000000EDEFCDAB" # dd REGION_END(0x37a164)
    # .replacements:
    # We pointerized everything so no fields were moved.
    - "00000000          " # dd LIST_END

  ExpHP.bullet-cap.item-mgr-layout:
    # istruc LayoutHeader
    - "705C570000000000  " # at LayoutHeader.location, dd LOCATION_STATIC(0x575c70)
    - "4C000000          " # at LayoutHeader.offset_to_replacements, dd item_mgr_layout.replacements - item_mgr_layout
    # iend
    # NOTE: To reduce binhacks, the last item in the array is not included in the pointerization; this is a dummy item
    # whose only purpose is to be returned by ItemManager::spawn_item when it fails to create an item.
    # (this is in contrast to bullets, where the dummy bullet is a sentinel for wraparound and must be pointerized)
    - "0000000042000000010000000100010000000000" # dd REGION_ARRAY_POINTERIZED(0, CAPID_CANCEL, SCALE_SIZE)
    - "60E00A0000000000000000000000000000000000" # dd REGION_NORMAL(0xae060)  ; offset of dummy item
    - "7CE50A0000000000000000000000000000000000EDEFCDAB" # dd REGION_END(0xae57c)
    # .replacements:
    # We pointerized everything so no fields were moved.
    - "00000000          " # dd LIST_END

  ExpHP.bullet-cap.perf-fix-data:
    - "00000000          " # dd 0  ; irrelevant, this game has no VM lists

  ExpHP.bullet-cap.pointerize-data:
    # istruc PointerizeData
    - "58F96200          " # at PointerizeData.bullet_mgr_base, dd 0x62f958
    - "18B26300          " # at PointerizeData.bullet_array_ptr, dd 0x62f958 + 0xb8c0
    - "805F9900          " # at PointerizeData.laser_array_ptr, dd 0x62f958 + 0x366628
    - "705C5700          " # at PointerizeData.item_mgr_base, dd 0x575c70
    - "705C5700          " # at PointerizeData.item_array_ptr, dd 0x575c70 + 0x0
    - "680D0000          " # at PointerizeData.bullet_size, dd 0xd68
    - "EC040000          " # at PointerizeData.laser_size, dd 0x4ec
    - "88020000          " # at PointerizeData.item_size, dd 0x288
    - "06000000          " # at PointerizeData.bullet_state_dummy_value, dd 6
    - "FC0B0000          " # at PointerizeData.bullet_state_offset, dd 0xbfc
    - "64A13700          " # at PointerizeData.bullet_mgr_size, dd 0x37a164
    - "7CE50A00          " # at PointerizeData.item_mgr_size, dd 0xae57c
    - "41D44700          " # at PointerizeData.func_malloc, dd 0x47d441
    # iend

  ExpHP.bullet-cap.iat-funcs:
    - "7CD04800          " # .GetLastError: dd 0x48d07c
    - "88D14800          " # .GetModuleHandleA: dd 0x48d188
    - "00000000          " # .GetModuleHandleW: dd 0
    - "5CD04800          " # .GetProcAddress: dd 0x48d05c
    - "E4D14800          " # .MessageBoxA: dd 0x48d1e4
